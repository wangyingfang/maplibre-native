{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MapLibre Android Examples","text":"<p>Welcome to the examples documentation of MapLibre Android.</p> <ul> <li> <p> Quickstart</p> <p>Learn how to include MapLibre Android in your project</p> <p> Getting started</p> </li> <li> <p> Find us on Slack</p> <p>Discuss the project and ask questions in the <code>#maplibre-android</code> channel</p> <p> Slack</p> </li> <li> <p> Contribute to these Docs</p> <p>Share your own examples with the community!</p> <p> Documentation on GitHub</p> </li> </ul>"},{"location":"#open-source-apps-using-maplibre-android","title":"Open-Source Apps Using MapLibre Android","text":"<p>You can learn how to use the API from MapLibre Android by stuying the source code of existing apps that intergrate MapLibre Android. Here are some open-source apps that use MapLibre Android:</p> <ul> <li>Streetcomplete (source code)</li> <li>The official Wikipedia app for Android (source code).</li> <li>MapLibreAndroidTestApp. This app is part of the MapLibre Native repository and is used for (automated) testing. Many of the examples in this documentation site come directly from this app.</li> </ul>"},{"location":"#see-also","title":"See Also","text":"<ul> <li>MapLibre Android API Documentation</li> <li>Source code on GitHub</li> <li>Latest releases</li> <li>GitHub Discussions</li> <li>MapLibre on Slack. Join the <code>#maplibre-native</code> and <code>#maplibre-android</code> channels.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This guide will explain various ways to create a map.</p> <p>When working with maps, you likely want to configure the <code>MapView</code>.</p> <p>There are several ways to build a <code>MapView</code>:</p> <ol> <li>Using existing XML namespace tags for<code>MapView</code> in the layout.</li> <li>Creating <code>MapLibreMapOptions</code> and passing builder function values into the <code>MapView</code>.</li> <li>Creating a <code>SupportMapFragment</code> with the help of <code>MapLibreMapOptions</code>.</li> </ol> <p>Before diving into <code>MapView</code> configurations, let's understand the capabilities of both XML namespaces and <code>MapLibreMapOptions</code>.</p> <p>Here are some common configurations you can set:</p> <ul> <li>Map base URI</li> <li>Camera settings</li> <li>Zoom level</li> <li>Pitch</li> <li>Gestures</li> <li>Compass</li> <li>Logo</li> <li>Attribution</li> <li>Placement of the above elements on the map and more</li> </ul> <p>We will explore how to achieve these configurations in XML layout and programmatically in Activity code, step by step.</p>"},{"location":"configuration/#mapview-configuration-with-an-xml-layout","title":"<code>MapView</code> Configuration with an XML layout","text":"<p>To configure <code>MapView</code> within an XML layout, you need to use the right namespace and provide the necessary data in the layout file.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/main\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".activity.options.MapOptionsXmlActivity\"&gt;\n\n    &lt;org.maplibre.android.maps.MapView\n        android:id=\"@+id/mapView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:maplibre_apiBaseUri=\"https://api.maplibre.org\"\n        app:maplibre_cameraBearing=\"0.0\"\n        app:maplibre_cameraPitchMax=\"90.0\"\n        app:maplibre_cameraPitchMin=\"0.0\"\n        app:maplibre_cameraTargetLat=\"42.31230486601532\"\n        app:maplibre_cameraTargetLng=\"64.63967338936439\"\n        app:maplibre_cameraTilt=\"0.0\"\n        app:maplibre_cameraZoom=\"3.9\"\n        app:maplibre_cameraZoomMax=\"26.0\"\n        app:maplibre_cameraZoomMin=\"2.0\"\n        app:maplibre_localIdeographFontFamilies=\"@array/array_local_ideograph_family_test\"\n        app:maplibre_localIdeographFontFamily=\"Droid Sans\"\n        app:maplibre_uiCompass=\"true\"\n        app:maplibre_uiCompassFadeFacingNorth=\"true\"\n        app:maplibre_uiCompassGravity=\"top|end\"\n        app:maplibre_uiDoubleTapGestures=\"true\"\n        app:maplibre_uiHorizontalScrollGestures=\"true\"\n        app:maplibre_uiRotateGestures=\"true\"\n        app:maplibre_uiScrollGestures=\"true\"\n        app:maplibre_uiTiltGestures=\"true\"\n        app:maplibre_uiZoomGestures=\"true\" /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre> <p>This can be found in <code>activity_map_options_xml.xml</code>.</p> <p>You can assign any other existing values to the <code>maplibre...</code> tags. Then, you only need to create <code>MapView</code> and <code>MapLibreMap</code> objects with a simple setup in the Activity.</p> <pre><code>package org.maplibre.android.testapp.activity.options\n\nimport android.os.Bundle\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.OnMapReadyCallback\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/**\n *  TestActivity demonstrating configuring MapView with XML\n */\n\nclass MapOptionsXmlActivity : AppCompatActivity(), OnMapReadyCallback {\n    private lateinit var mapView: MapView\n    private lateinit var maplibreMap: MapLibreMap\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_options_xml)\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync(this)\n    }\n\n    override fun onMapReady(maplibreMap: MapLibreMap) {\n        this.maplibreMap = maplibreMap\n        this.maplibreMap.setStyle(\"https://demotiles.maplibre.org/style.json\")\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n}\n</code></pre> <p>This can be found in <code>MapOptionsXmlActivity.kt</code>.</p>"},{"location":"configuration/#mapview-configuration-with-maplibremapoptions","title":"<code>MapView</code> configuration with <code>MapLibreMapOptions</code>","text":"<p>Here we don't have to create MapView from XML since we want to create it programmatically. <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;FrameLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/container\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"/&gt;\n</code></pre></p> <p>This can be found in <code>activity_map_options_runtime.xml</code>.</p> <p>A <code>MapLibreMapOptions</code> object must be created and passed to the MapView constructor. All setup is done in the Activity code:</p> <pre><code>\n</code></pre> <p>This can be found in <code>MapOptionsRuntimeActivity.kt</code>.</p> <p>Finally you will see a result similar to this:</p> <p>For the full contents of <code>MapOptionsRuntimeActivity</code> and <code>MapOptionsXmlActivity</code>, please take a look at the source code of MapLibreAndroidTestApp.</p> <p>You can read more about <code>MapLibreMapOptions</code> in the Android API documentation.</p>"},{"location":"configuration/#supportmapfragment-with-the-help-of-maplibremapoptions","title":"<code>SupportMapFragment</code> with the help of <code>MapLibreMapOptions</code>.","text":"<p>If you are using MapFragment in your project, it is also easy to provide initial values to the <code>newInstance()</code> static method of <code>SupportMapFragment</code>, which requires a <code>MapLibreMapOptions</code> parameter.</p> <p>Let's see how this can be done in a sample activity:</p> <pre><code>package org.maplibre.android.testapp.activity.fragment\n\nimport android.os.Bundle // ktlint-disable import-ordering\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.* // ktlint-disable no-wildcard-imports\nimport org.maplibre.android.maps.MapFragment.OnMapViewReadyCallback\nimport org.maplibre.android.maps.MapView.OnDidFinishRenderingFrameListener\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/**\n * Test activity showcasing using the MapFragment API using Support Library Fragments.\n *\n *\n * Uses MapLibreMapOptions to initialise the Fragment.\n *\n */\nclass SupportMapFragmentActivity :\n    AppCompatActivity(),\n    OnMapViewReadyCallback,\n    OnMapReadyCallback,\n    OnDidFinishRenderingFrameListener {\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var mapView: MapView\n    private var initialCameraAnimation = true\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_fragment)\n        val mapFragment: SupportMapFragment?\n        if (savedInstanceState == null) {\n            mapFragment = SupportMapFragment.newInstance(createFragmentOptions())\n            supportFragmentManager\n                .beginTransaction()\n                .add(R.id.fragment_container, mapFragment, TAG)\n                .commit()\n        } else {\n            mapFragment = supportFragmentManager.findFragmentByTag(TAG) as SupportMapFragment?\n        }\n        mapFragment!!.getMapAsync(this)\n    }\n\n    private fun createFragmentOptions(): MapLibreMapOptions {\n        val options = MapLibreMapOptions.createFromAttributes(this, null)\n        options.scrollGesturesEnabled(false)\n        options.zoomGesturesEnabled(false)\n        options.tiltGesturesEnabled(false)\n        options.rotateGesturesEnabled(false)\n        options.debugActive(false)\n        val dc = LatLng(38.90252, -77.02291)\n        options.minZoomPreference(9.0)\n        options.maxZoomPreference(11.0)\n        options.camera(\n            CameraPosition.Builder()\n                .target(dc)\n                .zoom(11.0)\n                .build()\n        )\n        return options\n    }\n\n    override fun onMapViewReady(map: MapView) {\n        mapView = map\n        mapView.addOnDidFinishRenderingFrameListener(this)\n    }\n\n    override fun onMapReady(map: MapLibreMap) {\n        maplibreMap = map\n        maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Satellite Hybrid\"))\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.removeOnDidFinishRenderingFrameListener(this)\n    }\n\n    override fun onDidFinishRenderingFrame(fully: Boolean, frameEncodingTime: Double, frameRenderingTime: Double) {\n        if (initialCameraAnimation &amp;&amp; fully &amp;&amp; this::maplibreMap.isInitialized) {\n            maplibreMap.animateCamera(\n                CameraUpdateFactory.newCameraPosition(CameraPosition.Builder().tilt(45.0).build()),\n                5000\n            )\n            initialCameraAnimation = false\n        }\n    }\n\n    companion object {\n        private const val TAG = \"com.mapbox.map\"\n    }\n}\n</code></pre> <p>You can also find the full contents of <code>SupportMapFragmentActivity</code> in the MapLibreAndroidTestApp.</p> <p>To learn more about <code>SupportMapFragment</code>, please visit the Android API documentation.</p>"},{"location":"getting-started/","title":"Quickstart","text":"<ol> <li> <p>Add bintray Maven repositories to your project-level Gradle file (usually <code>&lt;project&gt;/&lt;app-module&gt;/build.gradle</code>).</p> <pre><code>allprojects {\n    repositories {\n    ...\n    mavenCentral()\n    }\n}\n</code></pre> </li> <li> <p>Add the library as a dependency into your module Gradle file (usually <code>&lt;project&gt;/&lt;app-module&gt;/build.gradle</code>). Replace <code>&lt;version&gt;</code> with the latest MapLibre Android version (e.g.: <code>org.maplibre.gl:android-sdk:11.5.2</code>):</p> <pre><code>dependencies {\n    ...\n    implementation 'org.maplibre.gl:android-sdk:&lt;version&gt;'\n    ...\n}\n</code></pre> </li> <li> <p>Sync your Android project with Gradle files.</p> </li> <li> <p>Add a <code>MapView</code> to your layout XML file (usually <code>&lt;project&gt;/&lt;app-module&gt;/src/main/res/layout/activity_main.xml</code>).</p> <pre><code>...\n&lt;org.maplibre.android.maps.MapView\n    android:id=\"@+id/mapView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    /&gt;\n...\n</code></pre> </li> <li> <p>Initialize the <code>MapView</code> in your <code>MainActivity</code> file by following the example below:</p> <pre><code>import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport org.maplibre.android.Maplibre\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.testapp.R\n\nclass MainActivity : AppCompatActivity() {\n\n    // Declare a variable for MapView\n    private lateinit var mapView: MapView\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Init MapLibre\n        MapLibre.getInstance(this)\n\n        // Init layout view\n        val inflater = LayoutInflater.from(this)\n        val rootView = inflater.inflate(R.layout.activity_main, null)\n        setContentView(rootView)\n\n        // Init the MapView\n        mapView = rootView.findViewById(R.id.mapView)\n        mapView.getMapAsync { map -&gt;\n            map.setStyle(\"https://demotiles.maplibre.org/style.json\")\n            map.cameraPosition = CameraPosition.Builder().target(LatLng(0.0,0.0)).zoom(1.0).build()\n        }\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n}\n</code></pre> </li> <li> <p>Build and run the app. If you run the app successfully, a map will be displayed as seen in the screenshot below.</p> </li> </ol>"},{"location":"location-component/","title":"LocationComponent","text":"<p>This guide will demonstrate how to utilize the LocationComponent to represent the user's current location.</p> <p>When implementing the LocationComponent, the application should request location permissions.  Declare the need for foreground location in the <code>AndroidManifest.xml</code> file. For more information, please refer to the Android Developer Documentation.</p> <pre><code>&lt;manifest ... &gt;\n  &lt;!-- Always include this permission --&gt;\n  &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n\n  &lt;!-- Include only if your app benefits from precise location access. --&gt;\n  &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Create a new activity named <code>BasicLocationPulsingCircleActivity</code>:</p> <ul> <li>This Activity should implement the <code>OnMapReadyCallback</code> interface. The <code>onMapReady()</code> method is triggered when the map is ready to be used.</li> <li>Add a variable <code>permissionsManager</code> to manage permissions.</li> <li>Add a variable <code>locationComponent</code> to manage user location.</li> <li>At the end of the <code>onCreate()</code> method, call <code>checkPermissions()</code> to ensure that the application can access the user's location.</li> </ul> <pre><code>/**\n * This activity shows a basic usage of the LocationComponent's pulsing circle. There's no\n * customization of the pulsing circle's color, radius, speed, etc.\n */\nclass BasicLocationPulsingCircleActivity : AppCompatActivity(), OnMapReadyCallback {\n    private var lastLocation: Location? = null\n    private lateinit var mapView: MapView\n    private var permissionsManager: PermissionsManager? = null\n    private var locationComponent: LocationComponent? = null\n    private lateinit var maplibreMap: MapLibreMap\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_location_layer_basic_pulsing_circle)\n        mapView = findViewById(R.id.mapView)\n        if (savedInstanceState != null) {\n            lastLocation = savedInstanceState.getParcelable(SAVED_STATE_LOCATION, Location::class.java)\n        }\n        mapView.onCreate(savedInstanceState)\n        checkPermissions()\n    }\n</code></pre> <p>In the <code>checkPermissions()</code> method, the PermissionManager is used to request location permissions at runtime and handle the callbacks for permission granting or rejection.Additionally, you should pass the results of <code>Activity.onRequestPermissionResult()</code> to it. If the permissions are granted, call <code>mapView.getMapAsync(this)</code> to register the activity as a listener for onMapReady event.</p> <pre><code>private fun checkPermissions() {\n    if (PermissionsManager.areLocationPermissionsGranted(this)) {\n        mapView.getMapAsync(this)\n    } else {\n        permissionsManager = PermissionsManager(object : PermissionsListener {\n            override fun onExplanationNeeded(permissionsToExplain: List&lt;String&gt;) {\n                Toast.makeText(\n                    this@BasicLocationPulsingCircleActivity,\n                    \"You need to accept location permissions.\",\n                    Toast.LENGTH_SHORT\n                ).show()\n            }\n\n            override fun onPermissionResult(granted: Boolean) {\n                if (granted) {\n                    mapView.getMapAsync(this@BasicLocationPulsingCircleActivity)\n                } else {\n                    finish()\n                }\n            }\n        })\n        permissionsManager!!.requestLocationPermissions(this)\n    }\n}\n\noverride fun onRequestPermissionsResult(\n    requestCode: Int,\n    permissions: Array&lt;String&gt;,\n    grantResults: IntArray\n) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n    permissionsManager!!.onRequestPermissionsResult(requestCode, permissions, grantResults)\n}\n</code></pre> <p>In the <code>onMapReady()</code> method, first set the style and then handle the user's location using the LocationComponent.</p> <p>To configure the LocationComponent, developers should use LocationComponentOptions.</p> <p>In this demonstration, we create an instance of this class.</p> <p>In this method:</p> <ul> <li>Use the annotation <code>@SuppressLint(\"MissingPermission\")</code> to suppress warnings related to missing location access permissions.</li> <li>In <code>setStyle(),</code> you can utilize other public and token-free styles like demotiles instead of the predefined styles.</li> <li>For the builder of LocationComponentOptions, use <code>pulseEnabled(true)</code> to enable the pulse animation, which enhances awareness of the user's location.</li> <li>Use method <code>buildLocationComponentActivationOptions()</code> to set LocationComponentActivationOptions, then activate <code>locatinoComponent</code> with it.</li> <li>To apply options, make sure you call <code>activateLocationComponent()</code> of <code>locationComponent</code>. You can also set <code>locationComponent</code>'s various properties like <code>isLocationComponentEnabled</code> , <code>cameraMode</code> , etc...</li> <li><code>CameraMode.TRACKING</code><sup>1</sup> means that when the user's location is updated, the camera will reposition accordingly.</li> <li><code>locationComponent!!.forceLocationUpdate(lastLocation)</code> updates the the user's last known location.</li> </ul> <pre><code>@SuppressLint(\"MissingPermission\")\noverride fun onMapReady(maplibreMap: MapLibreMap) {\n    this.maplibreMap = maplibreMap\n    maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\")) { style: Style -&gt;\n        locationComponent = maplibreMap.locationComponent\n        val locationComponentOptions =\n            LocationComponentOptions.builder(this@BasicLocationPulsingCircleActivity)\n                .pulseEnabled(true)\n                .build()\n        val locationComponentActivationOptions =\n            buildLocationComponentActivationOptions(style, locationComponentOptions)\n        locationComponent!!.activateLocationComponent(locationComponentActivationOptions)\n        locationComponent!!.isLocationComponentEnabled = true\n        locationComponent!!.cameraMode = CameraMode.TRACKING\n        locationComponent!!.forceLocationUpdate(lastLocation)\n    }\n}\n</code></pre> <p>LocationComponentActivationOptions is used to hold the style, LocationComponentOptions and other locating behaviors.</p> <ul> <li>It can also be used to configure how to obtain the current location, such as LocationEngine and intervals.</li> <li>In this demonstration, it sets 750ms as the fastest interval for location updates, providing high accuracy location results (but with higher power consumption).</li> <li>For more information, please visit the documentation page.</li> </ul> <pre><code>private fun buildLocationComponentActivationOptions(\n    style: Style,\n    locationComponentOptions: LocationComponentOptions\n): LocationComponentActivationOptions {\n    return LocationComponentActivationOptions\n        .builder(this, style)\n        .locationComponentOptions(locationComponentOptions)\n        .useDefaultLocationEngine(true)\n        .locationEngineRequest(\n            LocationEngineRequest.Builder(750)\n                .setFastestInterval(750)\n                .setPriority(LocationEngineRequest.PRIORITY_HIGH_ACCURACY)\n                .build()\n        )\n        .build()\n}\n</code></pre> <p>For further customization, you can also utilize the <code>foregroundTintColor()</code> and <code>pulseColor()</code> methods on the LocationComponentOptions builder:</p> <pre><code>val locationComponentOptions =\n    LocationComponentOptions.builder(this@BasicLocationPulsingCircleActivity)\n       .pulseEnabled(true)\n       .pulseColor(Color.RED)             // Set color of pulse\n       .foregroundTintColor(Color.BLACK)  // Set color of user location\n       .build()\n</code></pre> <p>Here is the final results with different color configurations. For the complete content of this demo, please refer to the source code of the Test App.</p> <p></p> <ol> <li> <p>A variety of camera modes determine how the camera will track the user location.   They provide the right context to your users at the correct time.\u00a0\u21a9</p> </li> </ol>"},{"location":"snapshotter/","title":"Using the Snapshotter","text":"<p>This guide will help you walk through how to use MapSnapshotter.</p>"},{"location":"snapshotter/#map-snapshot-with-local-style","title":"Map Snapshot with Local Style","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterLocalStyleActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>To get started we will show how to use the map snapshotter with a local style.</p> <p>Add the source code of the Demotiles style as <code>demotiles.json</code> to the <code>res/raw</code> directory of our app<sup>1</sup>. First we will read this style:</p> <pre><code>val styleJson = resources.openRawResource(R.raw.demotiles).reader().readText()\n</code></pre> <p>Next, we configure the MapSnapshotter, passing height and width, the style we just read and the camera position:</p> <pre><code>mapSnapshotter = MapSnapshotter(\n    applicationContext,\n    MapSnapshotter.Options(\n        container.measuredWidth.coerceAtMost(1024),\n        container.measuredHeight.coerceAtMost(1024)\n    )\n        .withStyleBuilder(Style.Builder().fromJson(styleJson))\n        .withCameraPosition(\n            CameraPosition.Builder().target(LatLng(LATITUDE, LONGITUDE))\n                .zoom(ZOOM).build()\n        )\n)\n</code></pre> <p>Lastly we use the <code>.start()</code> method to create the snapshot, and pass callbacks for when the snapshot is ready or for when an error occurs.</p> <pre><code>mapSnapshotter.start({ snapshot -&gt;\n    Timber.i(\"Snapshot ready\")\n    val imageView = findViewById&lt;View&gt;(R.id.snapshot_image) as ImageView\n    imageView.setImageBitmap(snapshot.bitmap)\n}) { error -&gt; Timber.e(error )}\n</code></pre>"},{"location":"snapshotter/#show-a-grid-of-snapshots","title":"Show a Grid of Snapshots","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example, we demonstrate how to use the <code>MapSnapshotter</code> to create multiple map snapshots with different styles and camera positions, displaying them in a grid layout.</p> <p>First we create a <code>GridLayout</code> and a list of <code>MapSnapshotter</code> instances. We create a <code>Style.Builder</code> with a different style for each cell in the grid.</p> <pre><code>val styles = arrayOf(\n    TestStyles.DEMOTILES,\n    TestStyles.AMERICANA,\n    TestStyles.OPENFREEMAP_LIBERY,\n    TestStyles.AWS_OPEN_DATA_STANDARD_LIGHT,\n    TestStyles.PROTOMAPS_LIGHT,\n    TestStyles.PROTOMAPS_DARK,\n    TestStyles.PROTOMAPS_WHITE,\n    TestStyles.PROTOMAPS_GRAYSCALE,\n    TestStyles.VERSATILES\n)\nval builder = Style.Builder().fromUri(\n    styles[(row * grid.rowCount + column) % styles.size]\n)\n</code></pre> <p>Next we create a <code>MapSnapshotter.Options</code> object to customize the settings of each snapshot(ter).</p> <pre><code>val options = MapSnapshotter.Options(\n    grid.measuredWidth / grid.columnCount,\n    grid.measuredHeight / grid.rowCount\n)\n    .withPixelRatio(1f)\n    .withLocalIdeographFontFamily(MapLibreConstants.DEFAULT_FONT)\n</code></pre> <p>For some rows we randomize the visible region of the snapshot:</p> <pre><code>if (row % 2 == 0) {\n    options.withRegion(\n        LatLngBounds.Builder()\n            .include(\n                LatLng(\n                    randomInRange(-80f, 80f).toDouble(),\n                    randomInRange(-160f, 160f).toDouble()\n                )\n            )\n            .include(\n                LatLng(\n                    randomInRange(-80f, 80f).toDouble(),\n                    randomInRange(-160f, 160f).toDouble()\n                )\n            )\n            .build()\n    )\n}\n</code></pre> <p>For some columns we randomize the camera position:</p> <pre><code>if (column % 2 == 0) {\n    options.withCameraPosition(\n        CameraPosition.Builder()\n            .target(\n                options.region?.center ?: LatLng(\n                    randomInRange(-80f, 80f).toDouble(),\n                    randomInRange(-160f, 160f).toDouble()\n                )\n            )\n            .bearing(randomInRange(0f, 360f).toDouble())\n            .tilt(randomInRange(0f, 60f).toDouble())\n            .zoom(randomInRange(0f, 10f).toDouble())\n            .padding(1.0, 1.0, 1.0, 1.0)\n            .build()\n    )\n}\n</code></pre> <p>In the last column of the first row we add two bitmaps. See the next example for more details.</p> <pre><code>if (row == 0 &amp;&amp; column == 2) {\n    val carBitmap = BitmapUtils.getBitmapFromDrawable(\n        ResourcesCompat.getDrawable(resources, R.drawable.ic_directions_car_black, theme)\n    )\n\n    // Marker source\n    val markerCollection = FeatureCollection.fromFeatures(\n        arrayOf(\n            Feature.fromGeometry(\n                Point.fromLngLat(4.91638, 52.35673),\n                featureProperties(\"1\", \"Android\")\n            ),\n            Feature.fromGeometry(\n                Point.fromLngLat(4.91638, 12.34673),\n                featureProperties(\"2\", \"Car\")\n            )\n        )\n    )\n    val markerSource: Source = GeoJsonSource(MARKER_SOURCE, markerCollection)\n\n    // Marker layer\n    val markerSymbolLayer = SymbolLayer(MARKER_LAYER, MARKER_SOURCE)\n        .withProperties(\n            PropertyFactory.iconImage(Expression.get(TITLE_FEATURE_PROPERTY)),\n            PropertyFactory.iconIgnorePlacement(true),\n            PropertyFactory.iconAllowOverlap(true),\n            PropertyFactory.iconSize(\n                Expression.switchCase(\n                    Expression.toBool(Expression.get(SELECTED_FEATURE_PROPERTY)),\n                    Expression.literal(1.5f),\n                    Expression.literal(1.0f)\n                )\n            ),\n            PropertyFactory.iconAnchor(Property.ICON_ANCHOR_BOTTOM),\n            PropertyFactory.iconColor(Color.BLUE)\n        )\n    builder.withImage(\"Car\", Objects.requireNonNull(carBitmap!!), false)\n        .withSources(markerSource)\n        .withLayers(markerSymbolLayer)\n    options\n        .withRegion(null)\n        .withCameraPosition(\n            CameraPosition.Builder()\n                .target(\n                    LatLng(5.537109374999999, 52.07950600379697)\n                )\n                .zoom(1.0)\n                .padding(1.0, 1.0, 1.0, 1.0)\n                .build()\n        )\n}\n</code></pre>"},{"location":"snapshotter/#map-snapshot-with-bitmap-overlay","title":"Map Snapshot with Bitmap Overlay","text":"<p>Note</p> <p>You can also find this code in <code>MapSnapshotterBitMapOverlayActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example adds a bitmap on top of the snapshot. It also demonstrates how you can add a click listener to a snapshot.</p> MapSnapshotterBitMapOverlayActivity.kt<pre><code>package org.maplibre.android.testapp.activity.snapshot\n\nimport android.annotation.SuppressLint\nimport android.graphics.Bitmap\nimport android.graphics.BitmapFactory\nimport android.graphics.Canvas\nimport android.graphics.PointF\nimport android.os.Bundle\nimport android.view.MotionEvent\nimport android.view.View\nimport android.view.ViewTreeObserver.OnGlobalLayoutListener\nimport android.widget.ImageView\nimport androidx.annotation.VisibleForTesting\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.snapshotter.MapSnapshot\nimport org.maplibre.android.snapshotter.MapSnapshotter\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\nimport timber.log.Timber\n\n/**\n * Test activity showing how to use a the [MapSnapshotter] and overlay\n * [android.graphics.Bitmap]s on top.\n */\nclass MapSnapshotterBitMapOverlayActivity :\n    AppCompatActivity(),\n    MapSnapshotter.SnapshotReadyCallback {\n    private var mapSnapshotter: MapSnapshotter? = null\n\n    @get:VisibleForTesting\n    var mapSnapshot: MapSnapshot? = null\n        private set\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_map_snapshotter_marker)\n        val container = findViewById&lt;View&gt;(R.id.container)\n        container.viewTreeObserver\n            .addOnGlobalLayoutListener(object : OnGlobalLayoutListener {\n                override fun onGlobalLayout() {\n                    container.viewTreeObserver.removeOnGlobalLayoutListener(this)\n                    Timber.i(\"Starting snapshot\")\n                    mapSnapshotter = MapSnapshotter(\n                        applicationContext,\n                        MapSnapshotter.Options(\n                            Math.min(container.measuredWidth, 1024),\n                            Math.min(container.measuredHeight, 1024)\n                        )\n                            .withStyleBuilder(\n                                Style.Builder().fromUri(TestStyles.AMERICANA)\n                            )\n                            .withCameraPosition(\n                                CameraPosition.Builder().target(LatLng(52.090737, 5.121420))\n                                    .zoom(15.0).build()\n                            )\n                    )\n                    mapSnapshotter!!.start(this@MapSnapshotterBitMapOverlayActivity)\n                }\n            })\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapSnapshotter!!.cancel()\n    }\n\n    @SuppressLint(\"ClickableViewAccessibility\")\n    override fun onSnapshotReady(snapshot: MapSnapshot) {\n        mapSnapshot = snapshot\n        Timber.i(\"Snapshot ready\")\n        val imageView = findViewById&lt;View&gt;(R.id.snapshot_image) as ImageView\n        val image = addMarker(snapshot)\n        imageView.setImageBitmap(image)\n        imageView.setOnTouchListener { v: View?, event: MotionEvent -&gt;\n            if (event.action == MotionEvent.ACTION_DOWN) {\n                val latLng = snapshot.latLngForPixel(PointF(event.x, event.y))\n                Timber.e(\"Clicked LatLng is %s\", latLng)\n                return@setOnTouchListener true\n            }\n            false\n        }\n    }\n\n    private fun addMarker(snapshot: MapSnapshot): Bitmap {\n        val canvas = Canvas(snapshot.bitmap)\n        val marker =\n            BitmapFactory.decodeResource(resources, R.drawable.maplibre_marker_icon_default, null)\n        // Dom toren\n        val markerLocation = snapshot.pixelForLatLng(LatLng(52.090649433011315, 5.121310651302338))\n        canvas.drawBitmap(\n            marker, /* Subtract half of the width so we center the bitmap correctly */\n            markerLocation.x - marker.width / 2, /* Subtract half of the height so we align the bitmap bottom correctly */\n            markerLocation.y - marker.height / 2,\n            null\n        )\n        return snapshot.bitmap\n    }\n}\n</code></pre>"},{"location":"snapshotter/#map-snapshotter-with-heatmap-layer","title":"Map Snapshotter with Heatmap Layer","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterHeatMapActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example, we demonstrate how to use the <code>MapSnapshotter</code> to create a snapshot of a map that includes a heatmap layer. The heatmap represents earthquake data loaded from a GeoJSON source.</p> <p>First, we create the <code>MapSnapshotterHeatMapActivity</code> class, which extends <code>AppCompatActivity</code> and implements <code>MapSnapshotter.SnapshotReadyCallback</code> to receive the snapshot once it's ready.</p> <pre><code>class MapSnapshotterHeatMapActivity : AppCompatActivity(), MapSnapshotter.SnapshotReadyCallback {\n</code></pre> <p>In the <code>onCreate</code> method, we set up the layout and initialize the <code>MapSnapshotter</code> once the layout is ready.</p> <pre><code>override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_map_snapshotter_marker)\n    val container = findViewById&lt;View&gt;(R.id.container)\n    container.viewTreeObserver\n        .addOnGlobalLayoutListener(object : OnGlobalLayoutListener {\n            override fun onGlobalLayout() {\n                container.viewTreeObserver.removeOnGlobalLayoutListener(this)\n                Timber.i(\"Starting snapshot\")\n                val builder = Style.Builder().fromUri(TestStyles.AMERICANA)\n                    .withSource(earthquakeSource!!)\n                    .withLayerAbove(heatmapLayer, \"water\")\n                mapSnapshotter = MapSnapshotter(\n                    applicationContext,\n                    MapSnapshotter.Options(container.measuredWidth, container.measuredHeight)\n                        .withStyleBuilder(builder)\n                        .withCameraPosition(\n                            CameraPosition.Builder()\n                                .target(LatLng(15.0, (-94).toDouble()))\n                                .zoom(5.0)\n                                .padding(1.0, 1.0, 1.0, 1.0)\n                                .build()\n                        )\n                )\n                mapSnapshotter!!.start(this@MapSnapshotterHeatMapActivity)\n            }\n        })\n}\n</code></pre> <p>Here, we wait for the layout to be laid out using an <code>OnGlobalLayoutListener</code> before initializing the <code>MapSnapshotter</code>. We create a <code>Style.Builder</code> with a base style (<code>TestStyles.AMERICANA</code>), add the earthquake data source, and add the heatmap layer above the \"water\" layer.</p> <p>The <code>heatmapLayer</code> property defines the <code>HeatmapLayer</code> used to visualize the earthquake data.</p> <pre><code>private val heatmapLayer: HeatmapLayer\n    get() {\n        val layer = HeatmapLayer(HEATMAP_LAYER_ID, EARTHQUAKE_SOURCE_ID)\n        layer.maxZoom = 9f\n        layer.sourceLayer = HEATMAP_LAYER_SOURCE\n        layer.setProperties(\n            PropertyFactory.heatmapColor(\n                Expression.interpolate(\n                    Expression.linear(), Expression.heatmapDensity(),\n                    Expression.literal(0), Expression.rgba(33, 102, 172, 0),\n                    Expression.literal(0.2), Expression.rgb(103, 169, 207),\n                    Expression.literal(0.4), Expression.rgb(209, 229, 240),\n                    Expression.literal(0.6), Expression.rgb(253, 219, 199),\n                    Expression.literal(0.8), Expression.rgb(239, 138, 98),\n                    Expression.literal(1), Expression.rgb(178, 24, 43)\n                )\n            ),\n            PropertyFactory.heatmapWeight(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.get(\"mag\"),\n                    Expression.stop(0, 0),\n                    Expression.stop(6, 1)\n                )\n            ),\n            PropertyFactory.heatmapIntensity(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.zoom(),\n                    Expression.stop(0, 1),\n                    Expression.stop(9, 3)\n                )\n            ),\n            PropertyFactory.heatmapRadius(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.zoom(),\n                    Expression.stop(0, 2),\n                    Expression.stop(9, 20)\n                )\n            ),\n            PropertyFactory.heatmapOpacity(\n                Expression.interpolate(\n                    Expression.linear(),\n                    Expression.zoom(),\n                    Expression.stop(7, 1),\n                    Expression.stop(9, 0)\n                )\n            )\n        )\n        return layer\n    }\n</code></pre> <p>This code sets up the heatmap layer's properties, such as color ramp, weight, intensity, radius, and opacity, using expressions that interpolate based on data properties and zoom level.</p> <p>We also define the <code>earthquakeSource</code>, which loads data from a GeoJSON file containing earthquake information.</p> <pre><code>private val earthquakeSource: Source?\n    get() {\n        var source: Source? = null\n        try {\n            source = GeoJsonSource(EARTHQUAKE_SOURCE_ID, URI(EARTHQUAKE_SOURCE_URL))\n        } catch (uriSyntaxException: URISyntaxException) {\n            Timber.e(uriSyntaxException, \"That's not a valid URL.\")\n        }\n        return source\n    }\n</code></pre> <p>When the snapshot is ready, the <code>onSnapshotReady</code> callback is invoked, where we set the snapshot bitmap to an <code>ImageView</code> to display it.</p> <pre><code>@SuppressLint(\"ClickableViewAccessibility\")\noverride fun onSnapshotReady(snapshot: MapSnapshot) {\n    Timber.i(\"Snapshot ready\")\n    val imageView = findViewById&lt;ImageView&gt;(R.id.snapshot_image)\n    imageView.setImageBitmap(snapshot.bitmap)\n}\n</code></pre> <p>Finally, we ensure to cancel the snapshotter in the <code>onStop</code> method to free up resources.</p> <pre><code>override fun onStop() {\n    super.onStop()\n    mapSnapshotter?.cancel()\n}\n</code></pre>"},{"location":"snapshotter/#map-snapshotter-with-expression","title":"Map Snapshotter with Expression","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MapSnapshotterWithinExpression.kt</code> of the MapLibreAndroidTestApp.</p> <p>In this example the map on top is a live while the map on the bottom is a snapshot that is updated as you pan the map. We style of the snapshot is modified: using a within expression only POIs within a certain distance to a line is shown. A highlight for this area is added to the map as are various points.</p> MapSnapshotterWithinExpression.kt<pre><code>package org.maplibre.android.testapp.activity.turf\n\nimport android.graphics.Color\nimport android.os.Bundle\nimport android.os.PersistableBundle\nimport androidx.appcompat.app.AppCompatActivity\nimport org.maplibre.geojson.*\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.Style\nimport org.maplibre.android.snapshotter.MapSnapshot\nimport org.maplibre.android.snapshotter.MapSnapshotter\nimport org.maplibre.android.style.expressions.Expression.within\nimport org.maplibre.android.style.layers.CircleLayer\nimport org.maplibre.android.style.layers.FillLayer\nimport org.maplibre.android.style.layers.LineLayer\nimport org.maplibre.android.style.layers.Property.NONE\nimport org.maplibre.android.style.layers.PropertyFactory.*\nimport org.maplibre.android.style.layers.SymbolLayer\nimport org.maplibre.android.style.sources.GeoJsonOptions\nimport org.maplibre.android.style.sources.GeoJsonSource\nimport org.maplibre.android.testapp.databinding.ActivityMapsnapshotterWithinExpressionBinding\nimport org.maplibre.android.testapp.styles.TestStyles.getPredefinedStyleWithFallback\n\n/**\n * An Activity that showcases the use of MapSnapshotter with 'within' expression\n */\nclass MapSnapshotterWithinExpression : AppCompatActivity() {\n    private lateinit var binding: ActivityMapsnapshotterWithinExpressionBinding\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var snapshotter: MapSnapshotter\n    private var snapshotInProgress = false\n\n    private val cameraListener = object : MapView.OnCameraDidChangeListener {\n        override fun onCameraDidChange(animated: Boolean) {\n            if (!snapshotInProgress) {\n                snapshotInProgress = true\n                snapshotter.setCameraPosition(maplibreMap.cameraPosition)\n                snapshotter.start(object : MapSnapshotter.SnapshotReadyCallback {\n                    override fun onSnapshotReady(snapshot: MapSnapshot) {\n                        binding.imageView.setImageBitmap(snapshot.bitmap)\n                        snapshotInProgress = false\n                    }\n                })\n            }\n        }\n    }\n\n    private val snapshotterObserver = object : MapSnapshotter.Observer {\n        override fun onStyleImageMissing(imageName: String) {\n        }\n\n        override fun onDidFinishLoadingStyle() {\n            // Show only POI labels inside geometry using within expression\n            (snapshotter.getLayer(\"poi-label\") as SymbolLayer).setFilter(\n                within(\n                    bufferLineStringGeometry()\n                )\n            )\n            // Hide other types of labels to highlight POI labels\n            (snapshotter.getLayer(\"road-label\") as SymbolLayer).setProperties(visibility(NONE))\n            (snapshotter.getLayer(\"transit-label\") as SymbolLayer).setProperties(visibility(NONE))\n            (snapshotter.getLayer(\"road-number-shield\") as SymbolLayer).setProperties(visibility(NONE))\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMapsnapshotterWithinExpressionBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        binding.mapView.onCreate(savedInstanceState)\n        binding.mapView.getMapAsync { map -&gt;\n            maplibreMap = map\n\n            // Setup camera position above Georgetown\n            maplibreMap.cameraPosition = CameraPosition.Builder().target(LatLng(38.90628988399711, -77.06574689337494)).zoom(15.5).build()\n\n            // Wait for the map to become idle before manipulating the style and camera of the map\n            binding.mapView.addOnDidBecomeIdleListener(object : MapView.OnDidBecomeIdleListener {\n                override fun onDidBecomeIdle() {\n                    maplibreMap.easeCamera(\n                        CameraUpdateFactory.newCameraPosition(\n                            CameraPosition.Builder().zoom(16.0).target(LatLng(38.905156245642814, -77.06535338052844)).bearing(80.68015859462369).tilt(55.0).build()\n                        ),\n                        1000\n                    )\n                    binding.mapView.removeOnDidBecomeIdleListener(this)\n                }\n            })\n            // Load mapbox streets and add lines and circles\n            setupStyle()\n        }\n    }\n\n    private fun setupStyle() {\n        // Assume the route is represented by an array of coordinates.\n        val coordinates = listOf&lt;Point&gt;(\n            Point.fromLngLat(-77.06866264343262, 38.90506061276737),\n            Point.fromLngLat(-77.06283688545227, 38.905194197410545),\n            Point.fromLngLat(-77.06285834312439, 38.906429843444094),\n            Point.fromLngLat(-77.0630407333374, 38.90680554236621)\n        )\n\n        // Setup style with additional layers,\n        // using streets as a base style\n        maplibreMap.setStyle(\n            Style.Builder().fromUri(getPredefinedStyleWithFallback(\"Streets\"))\n        ) {\n            binding.mapView.addOnCameraDidChangeListener(cameraListener)\n        }\n\n        val options = MapSnapshotter.Options(binding.imageView.measuredWidth / 2, binding.imageView.measuredHeight / 2)\n            .withCameraPosition(maplibreMap.cameraPosition)\n            .withPixelRatio(2.0f).withStyleBuilder(\n                Style.Builder().fromUri(getPredefinedStyleWithFallback(\"Streets\")).withSources(\n                    GeoJsonSource(\n                        POINT_ID,\n                        LineString.fromLngLats(coordinates)\n                    ),\n                    GeoJsonSource(\n                        FILL_ID,\n                        FeatureCollection.fromFeature(\n                            Feature.fromGeometry(bufferLineStringGeometry())\n                        ),\n                        GeoJsonOptions().withBuffer(0).withTolerance(0.0f)\n                    )\n                ).withLayerBelow(\n                    LineLayer(LINE_ID, POINT_ID).withProperties(\n                        lineWidth(7.5f),\n                        lineColor(Color.LTGRAY)\n                    ),\n                    \"poi-label\"\n                ).withLayerBelow(\n                    CircleLayer(POINT_ID, POINT_ID).withProperties(\n                        circleRadius(7.5f),\n                        circleColor(Color.DKGRAY),\n                        circleOpacity(0.75f)\n                    ),\n                    \"poi-label\"\n                ).withLayerBelow(\n                    FillLayer(FILL_ID, FILL_ID).withProperties(\n                        fillOpacity(0.12f),\n                        fillColor(Color.YELLOW)\n                    ),\n                    LINE_ID\n                )\n            )\n        snapshotter = MapSnapshotter(this, options)\n        snapshotter.setObserver(snapshotterObserver)\n    }\n\n    override fun onStart() {\n        super.onStart()\n        binding.mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        binding.mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        binding.mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        binding.mapView.onStop()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        binding.mapView.onLowMemory()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        binding.mapView.onDestroy()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle, outPersistentState: PersistableBundle) {\n        super.onSaveInstanceState(outState, outPersistentState)\n        binding.mapView.onSaveInstanceState(outState)\n    }\n\n    private fun bufferLineStringGeometry(): Polygon {\n        // TODO replace static data by Turf#Buffer: mapbox-java/issues/987\n        return FeatureCollection.fromJson(\n            \"\"\"\n            {\n              \"type\": \"FeatureCollection\",\n              \"features\": [\n                {\n                  \"type\": \"Feature\",\n                  \"properties\": {},\n                  \"geometry\": {\n                    \"type\": \"Polygon\",\n                    \"coordinates\": [\n                      [\n                        [\n                          -77.06867337226866,\n                          38.90467655551809\n                        ],\n                        [\n                          -77.06233263015747,\n                          38.90479344272695\n                        ],\n                        [\n                          -77.06234335899353,\n                          38.906463238984344\n                        ],\n                        [\n                          -77.06290125846863,\n                          38.907206285691615\n                        ],\n                        [\n                          -77.06364154815674,\n                          38.90684728656818\n                        ],\n                        [\n                          -77.06326603889465,\n                          38.90637140121084\n                        ],\n                        [\n                          -77.06321239471436,\n                          38.905561553883246\n                        ],\n                        [\n                          -77.0691454410553,\n                          38.905436318935635\n                        ],\n                        [\n                          -77.06912398338318,\n                          38.90466820642439\n                        ],\n                        [\n                          -77.06867337226866,\n                          38.90467655551809\n                        ]\n                      ]\n                    ]\n                  }\n                }\n              ]\n            }\n            \"\"\".trimIndent()\n        ).features()!![0].geometry() as Polygon\n    }\n\n    companion object {\n        const val POINT_ID = \"point\"\n        const val FILL_ID = \"fill\"\n        const val LINE_ID = \"line\"\n    }\n}\n</code></pre> <ol> <li> <p>See App resources overview for this and other ways you can provide resources to your app.\u00a0\u21a9</p> </li> </ol>"},{"location":"annotations/add-markers/","title":"Add Markers in Bulk","text":"<p>This example demonstrates how you can add markers in bulk.</p> BulkMarkerActivity.kt<pre><code>package org.maplibre.android.testapp.activity.annotation\n\nimport android.app.ProgressDialog\nimport android.os.Bundle\nimport android.view.Menu\nimport android.view.View\nimport android.widget.AdapterView\nimport android.widget.AdapterView.OnItemSelectedListener\nimport android.widget.ArrayAdapter\nimport android.widget.Spinner\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.lifecycleScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport org.maplibre.android.annotations.MarkerOptions\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\nimport org.maplibre.android.testapp.utils.GeoParseUtil\nimport timber.log.Timber\nimport java.io.IOException\nimport java.text.DecimalFormat\nimport java.util.*\nimport kotlin.math.min\n\n/**\n * Test activity showcasing adding a large amount of Markers.\n */\nclass BulkMarkerActivity : AppCompatActivity(), OnItemSelectedListener {\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var mapView: MapView\n    private var locations: List&lt;LatLng&gt;? = null\n    private var progressDialog: ProgressDialog? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_marker_bulk)\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync { initMap(it) }\n    }\n\n    private fun initMap(maplibreMap: MapLibreMap) {\n        this.maplibreMap = maplibreMap\n        maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\"))\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        val spinnerAdapter = ArrayAdapter.createFromResource(\n            this,\n            R.array.bulk_marker_list,\n            android.R.layout.simple_spinner_item\n        )\n        spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)\n        menuInflater.inflate(R.menu.menu_bulk_marker, menu)\n        val item = menu.findItem(R.id.spinner)\n        val spinner = item.actionView as Spinner\n        spinner.adapter = spinnerAdapter\n        spinner.onItemSelectedListener = this@BulkMarkerActivity\n        return true\n    }\n\n    override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View, position: Int, id: Long) {\n        val amount = Integer.valueOf(resources.getStringArray(R.array.bulk_marker_list)[position])\n        if (locations == null) {\n            progressDialog = ProgressDialog.show(this, \"Loading\", \"Fetching markers\", false)\n            lifecycleScope.launch(Dispatchers.IO) {\n                locations = loadLocationTask(this@BulkMarkerActivity)\n                withContext(Dispatchers.Main) {\n                    onLatLngListLoaded(locations, amount)\n                }\n            }\n        } else {\n            showMarkers(amount)\n        }\n    }\n\n    private fun onLatLngListLoaded(latLngs: List&lt;LatLng&gt;?, amount: Int) {\n        progressDialog!!.hide()\n        locations = latLngs\n        showMarkers(amount)\n    }\n\n    private fun showMarkers(amount: Int) {\n        if (!this::maplibreMap.isInitialized || locations == null || mapView.isDestroyed) {\n            return\n        }\n        maplibreMap.clear()\n        showGlMarkers(min(amount, locations!!.size))\n    }\n\n    private fun showGlMarkers(amount: Int) {\n        val markerOptionsList: MutableList&lt;MarkerOptions&gt; = ArrayList()\n        val formatter = DecimalFormat(\"#.#####\")\n        val random = Random()\n        var randomIndex: Int\n        for (i in 0 until amount) {\n            randomIndex = random.nextInt(locations!!.size)\n            val latLng = locations!![randomIndex]\n            markerOptionsList.add(\n                MarkerOptions()\n                    .position(latLng)\n                    .title(i.toString())\n                    .snippet(formatter.format(latLng.latitude) + \"`, \" + formatter.format(latLng.longitude))\n            )\n        }\n        maplibreMap.addMarkers(markerOptionsList)\n    }\n\n    override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) {\n        // nothing selected, nothing to do!\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        if (progressDialog != null) {\n            progressDialog!!.dismiss()\n        }\n        mapView.onDestroy()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    private fun loadLocationTask(\n        activity: BulkMarkerActivity,\n    ) : List&lt;LatLng&gt;? {\n        try {\n            val json = GeoParseUtil.loadStringFromAssets(\n                activity.applicationContext,\n                \"points.geojson\"\n            )\n            return GeoParseUtil.parseGeoJsonCoordinates(json)\n        } catch (exception: IOException) {\n            Timber.e(exception, \"Could not add markers\")\n        }\n        return null\n    }\n}\n</code></pre>"},{"location":"annotations/marker-annotations/","title":"Annotation: Marker","text":"<p>This guide will show you how to add Markers in the map.</p> <p><code>Annotation</code> is an overlay on top of a Map. In package <code>org.maplibre.android.annotations</code>, it has the following subclasses:</p> <ol> <li>Marker</li> <li>Polyline</li> <li>Polygon</li> </ol> <p>A Marker shows an icon image at a geographical location. By default, marker uses a provided image as its icon.</p> <p></p> <p>Or, the icon can be customized using IconFactory to generate an Icon using a provided image.</p> <p>For more customization, please read the documentation about MarkerOptions.</p> <p>In this showcase, we continue the code from the Quickstart, rename Activity into <code>JsonApiActivity</code>, and pull the GeoJSON data from a free and public API. Then add markers to the map with GeoJSON:</p> <ol> <li> <p>In your module Gradle file (usually <code>&lt;project&gt;/&lt;app-module&gt;/build.gradle</code>), add <code>okhttp</code> to simplify code for making HTTP requests.   <pre><code>dependencies {\n    ...\n    implementation 'com.squareup.okhttp3:okhttp:4.10.0'\n    ...\n}\n</code></pre></p> </li> <li> <p>Sync your Android project the with Gradle files.</p> </li> <li> <p>In <code>JsonApiActivity</code> we add a new variable for <code>MapLibreMap</code>.    It is used to add annotations to the map instance.   <pre><code>class JsonApiActivity : AppCompatActivity() {\n\n    // Declare a variable for MapView\n    private lateinit var mapView: MapView\n\n    // Declare a variable for MapLibreMap\n    private lateinit var maplibreMap: MapLibreMap\n</code></pre></p> </li> <li> <p>Call <code>mapview.getMapSync()</code> in order to get a <code>MapLibreMap</code> object.    After <code>maplibreMap</code> is assigned, call the <code>getEarthQuakeDataFromUSGS()</code> method    to make a HTTP request and transform data into the map annotations.   <pre><code>mapView.getMapAsync { map -&gt;\n    maplibreMap = map\n\n    maplibreMap.setStyle(\"https://demotiles.maplibre.org/style.json\")\n\n    // Fetch data from USGS\n    getEarthQuakeDataFromUSGS()\n}\n</code></pre></p> </li> <li> <p>Define a function <code>getEarthQuakeDataFromUSGS()</code> to fetch GeoJSON data from a public API.    If we successfully get the response, call <code>addMarkersToMap()</code> on the UI thread.   <pre><code>// Get Earthquake data from usgs.gov, read API doc at:\n// https://earthquake.usgs.gov/fdsnws/event/1/\nprivate fun getEarthQuakeDataFromUSGS() {\n    val url = \"https://earthquake.usgs.gov/fdsnws/event/1/query\".toHttpUrl().newBuilder()\n        .addQueryParameter(\"format\", \"geojson\")\n        .addQueryParameter(\"starttime\", \"2022-01-01\")\n        .addQueryParameter(\"endtime\", \"2022-12-31\")\n        .addQueryParameter(\"minmagnitude\", \"5.8\")\n        .addQueryParameter(\"latitude\", \"24\")\n        .addQueryParameter(\"longitude\", \"121\")\n        .addQueryParameter(\"maxradius\", \"1.5\")\n        .build()\n    val request: Request = Request.Builder().url(url).build()\n\n    OkHttpClient().newCall(request).enqueue(object : Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            Toast.makeText(this@JsonApiActivity, \"Fail to fetch data\", Toast.LENGTH_SHORT)\n                .show()\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            val featureCollection = response.body?.string()\n                ?.let(FeatureCollection::fromJson)\n                ?: return\n            // If FeatureCollection in response is not null\n            // Then add markers to map\n            runOnUiThread { addMarkersToMap(featureCollection) }\n        }\n    })\n}\n</code></pre></p> </li> <li> <p>Now it is time to add markers into the map.</p> </li> <li>In the <code>addMarkersToMap()</code> method, we define two types of bitmap for the marker icon.</li> <li>For each feature in the GeoJSON, add a marker with a snippet about earthquake details.</li> <li>If the magnitude of an earthquake is bigger than 6.0, we use the red icon. Otherwise, we use the blue one.</li> <li> <p>Finally, move the camera to the bounds of the newly added markers   <pre><code>private fun addMarkersToMap(data: FeatureCollection) {\n    val bounds = mutableListOf&lt;LatLng&gt;()\n\n    // Get bitmaps for marker icon\n    val infoIconDrawable = ResourcesCompat.getDrawable(\n        this.resources,\n        // Intentionally specify package name\n        // This makes copy from another project easier\n        org.maplibre.android.R.drawable.maplibre_info_icon_default,\n        theme\n    )!!\n    val bitmapBlue = infoIconDrawable.toBitmap()\n    val bitmapRed = infoIconDrawable\n        .mutate()\n        .apply { setTint(Color.RED) }\n        .toBitmap()\n\n    // Add symbol for each point feature\n    data.features()?.forEach { feature -&gt;\n        val geometry = feature.geometry()?.toJson() ?: return@forEach\n        val point = Point.fromJson(geometry) ?: return@forEach\n        val latLng = LatLng(point.latitude(), point.longitude())\n        bounds.add(latLng)\n\n        // Contents in InfoWindow of each marker\n        val title = feature.getStringProperty(\"title\")\n        val epochTime = feature.getNumberProperty(\"time\")\n        val dateString = SimpleDateFormat(\"yyyy/MM/dd HH:mm\", Locale.TAIWAN).format(epochTime)\n\n        // If magnitude &gt; 6.0, show marker with red icon. If not, show blue icon instead\n        val mag = feature.getNumberProperty(\"mag\")\n        val icon = IconFactory.getInstance(this)\n            .fromBitmap(if (mag.toFloat() &gt; 6.0) bitmapRed else bitmapBlue)\n\n        // Use MarkerOptions and addMarker() to add a new marker in map\n        val markerOptions = MarkerOptions()\n            .position(latLng)\n            .title(dateString)\n            .snippet(title)\n            .icon(icon)\n        maplibreMap.addMarker(markerOptions)\n    }\n\n    // Move camera to newly added annotations\n    maplibreMap.getCameraForLatLngBounds(LatLngBounds.fromLatLngs(bounds))?.let {\n        val newCameraPosition = CameraPosition.Builder()\n            .target(it.target)\n            .zoom(it.zoom - 0.5)\n            .build()\n        maplibreMap.cameraPosition = newCameraPosition\n    }\n}\n</code></pre></p> </li> <li> <p>Here is the final result. For the full contents of <code>JsonApiActivity</code>, please visit source code of our Test App.</p> </li> </ol>"},{"location":"camera/animation-types/","title":"Animation Types","text":"<p>Note</p> <p>You can find the full source code of this example in <code>CameraAnimationTypeActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example showcases the different animation types.</p> <ul> <li>Move: available via the <code>MapLibreMap.moveCamera</code> method.</li> <li>Ease: available via the <code>MapLibreMap.easeCamera</code> method.</li> <li>Animate: available via the <code>MapLibreMap.animateCamera</code> method.</li> </ul>"},{"location":"camera/animation-types/#move","title":"Move","text":"<p>The <code>MapLibreMap.moveCamera</code> method jumps to the camera position provided.</p> <pre><code>val cameraPosition =\n    CameraPosition.Builder()\n        .target(nextLatLng)\n        .zoom(14.0)\n        .tilt(30.0)\n        .tilt(0.0)\n        .build()\nmaplibreMap.moveCamera(CameraUpdateFactory.newCameraPosition(cameraPosition))\n</code></pre>"},{"location":"camera/animation-types/#ease","title":"Ease","text":"<p>The <code>MapLibreMap.moveCamera</code> eases to the camera position provided (with constant ground speed).</p> <pre><code>val cameraPosition =\n    CameraPosition.Builder()\n        .target(nextLatLng)\n        .zoom(15.0)\n        .bearing(180.0)\n        .tilt(30.0)\n        .build()\nmaplibreMap.easeCamera(\n    CameraUpdateFactory.newCameraPosition(cameraPosition),\n    7500,\n    callback\n)\n</code></pre>"},{"location":"camera/animation-types/#animate","title":"Animate","text":"<p>The <code>MapLibreMap.animateCamera</code> uses a powered flight animation move to the camera position provided<sup>1</sup>.</p> <pre><code>val cameraPosition =\n    CameraPosition.Builder().target(nextLatLng).bearing(270.0).tilt(20.0).build()\nmaplibreMap.animateCamera(\n    CameraUpdateFactory.newCameraPosition(cameraPosition),\n    7500,\n    callback\n)\n</code></pre>"},{"location":"camera/animation-types/#animation-callbacks","title":"Animation Callbacks","text":"<p>In the previous section a <code>CancellableCallback</code> was passed to the last two animation methods. This callback shows a toast message when the animation is cancelled or when it is finished.</p> <pre><code>private val callback: CancelableCallback =\n    object : CancelableCallback {\n        override fun onCancel() {\n            Timber.i(\"Duration onCancel Callback called.\")\n            Toast.makeText(\n                applicationContext,\n                \"Ease onCancel Callback called.\",\n                Toast.LENGTH_LONG\n            )\n                .show()\n        }\n\n        override fun onFinish() {\n            Timber.i(\"Duration onFinish Callback called.\")\n            Toast.makeText(\n                applicationContext,\n                \"Ease onFinish Callback called.\",\n                Toast.LENGTH_LONG\n            )\n                .show()\n        }\n    }\n</code></pre> <ol> <li> <p>The implementation is based on  Van Wijk, Jarke J.; Nuij, Wim A. A. \u201cSmooth and efficient zooming and panning.\u201d INFOVIS \u201903. pp. 15\u201322. https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5 \u21a9</p> </li> </ol>"},{"location":"camera/animator-animation/","title":"Animator Animation","text":"<p>This example showcases how to use the Animator API to schedule a sequence of map animations.</p> CameraAnimatorActivity.kt<pre><code>package org.maplibre.android.testapp.activity.camera\n\nimport android.animation.Animator\nimport android.animation.AnimatorSet\nimport android.animation.TypeEvaluator\nimport android.animation.ValueAnimator\nimport android.os.Bundle\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport android.view.animation.AnticipateOvershootInterpolator\nimport android.view.animation.BounceInterpolator\nimport android.view.animation.Interpolator\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.collection.LongSparseArray\nimport androidx.core.view.animation.PathInterpolatorCompat\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\nimport androidx.interpolator.view.animation.FastOutSlowInInterpolator\nimport org.maplibre.android.camera.CameraPosition\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.*\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\n\n/** Test activity showcasing using Android SDK animators to animate camera position changes. */\nclass CameraAnimatorActivity : AppCompatActivity(), OnMapReadyCallback {\n    private val animators = LongSparseArray&lt;Animator&gt;()\n    private lateinit var set: Animator\n    private lateinit var mapView: MapView\n    private lateinit var maplibreMap: MapLibreMap\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_camera_animator)\n        mapView = findViewById&lt;View&gt;(R.id.mapView) as MapView\n        if (::mapView.isInitialized) {\n            mapView.onCreate(savedInstanceState)\n            mapView.getMapAsync(this)\n        }\n    }\n\n    override fun onMapReady(map: MapLibreMap) {\n        maplibreMap = map\n        map.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\"))\n        initFab()\n    }\n\n    private fun initFab() {\n        findViewById&lt;View&gt;(R.id.fab).setOnClickListener { view: View -&gt;\n            view.visibility = View.GONE\n            val animatedPosition =\n                CameraPosition.Builder()\n                    .target(LatLng(37.789992, -122.402214))\n                    .tilt(60.0)\n                    .zoom(14.5)\n                    .bearing(135.0)\n                    .build()\n            set = createExampleAnimator(maplibreMap.cameraPosition, animatedPosition)\n            set.start()\n        }\n    }\n\n    //\n    // Animator API used for the animation on the FAB\n    //\n    private fun createExampleAnimator(\n        currentPosition: CameraPosition,\n        targetPosition: CameraPosition\n    ): Animator {\n        val animatorSet = AnimatorSet()\n        animatorSet.play(createLatLngAnimator(currentPosition.target!!, targetPosition.target!!))\n        animatorSet.play(createZoomAnimator(currentPosition.zoom, targetPosition.zoom))\n        animatorSet.play(createBearingAnimator(currentPosition.bearing, targetPosition.bearing))\n        animatorSet.play(createTiltAnimator(currentPosition.tilt, targetPosition.tilt))\n        return animatorSet\n    }\n\n    private fun createLatLngAnimator(currentPosition: LatLng, targetPosition: LatLng): Animator {\n        val latLngAnimator =\n            ValueAnimator.ofObject(LatLngEvaluator(), currentPosition, targetPosition)\n        latLngAnimator.duration = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        latLngAnimator.interpolator = FastOutSlowInInterpolator()\n        latLngAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.newLatLng((animation.animatedValue as LatLng))\n            )\n        }\n        return latLngAnimator\n    }\n\n    private fun createZoomAnimator(currentZoom: Double, targetZoom: Double): Animator {\n        val zoomAnimator = ValueAnimator.ofFloat(currentZoom.toFloat(), targetZoom.toFloat())\n        zoomAnimator.duration = (2200 * ANIMATION_DELAY_FACTOR).toLong()\n        zoomAnimator.startDelay = (600 * ANIMATION_DELAY_FACTOR).toLong()\n        zoomAnimator.interpolator = AnticipateOvershootInterpolator()\n        zoomAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.zoomTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return zoomAnimator\n    }\n\n    private fun createBearingAnimator(currentBearing: Double, targetBearing: Double): Animator {\n        val bearingAnimator =\n            ValueAnimator.ofFloat(currentBearing.toFloat(), targetBearing.toFloat())\n        bearingAnimator.duration = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        bearingAnimator.startDelay = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        bearingAnimator.interpolator = FastOutLinearInInterpolator()\n        bearingAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.bearingTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return bearingAnimator\n    }\n\n    private fun createTiltAnimator(currentTilt: Double, targetTilt: Double): Animator {\n        val tiltAnimator = ValueAnimator.ofFloat(currentTilt.toFloat(), targetTilt.toFloat())\n        tiltAnimator.duration = (1000 * ANIMATION_DELAY_FACTOR).toLong()\n        tiltAnimator.startDelay = (1500 * ANIMATION_DELAY_FACTOR).toLong()\n        tiltAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.tiltTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return tiltAnimator\n    }\n\n    //\n    // Interpolator examples\n    //\n    private fun obtainExampleInterpolator(menuItemId: Int): Animator? {\n        return animators[menuItemId.toLong()]\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        menuInflater.inflate(R.menu.menu_animator, menu)\n        return true\n    }\n\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        if (!::maplibreMap.isInitialized) {\n            return false\n        }\n        if (item.itemId != android.R.id.home) {\n            findViewById&lt;View&gt;(R.id.fab).visibility = View.GONE\n            resetCameraPosition()\n            playAnimation(item.itemId)\n        }\n        return super.onOptionsItemSelected(item)\n    }\n\n    private fun resetCameraPosition() {\n        maplibreMap.moveCamera(\n            CameraUpdateFactory.newCameraPosition(\n                CameraPosition.Builder()\n                    .target(START_LAT_LNG)\n                    .zoom(11.0)\n                    .bearing(0.0)\n                    .tilt(0.0)\n                    .build()\n            )\n        )\n    }\n\n    private fun playAnimation(itemId: Int) {\n        val animator = obtainExampleInterpolator(itemId)\n        if (animator != null) {\n            animator.cancel()\n            animator.start()\n        }\n    }\n\n    private fun obtainExampleInterpolator(interpolator: Interpolator, duration: Long): Animator {\n        val zoomAnimator = ValueAnimator.ofFloat(11.0f, 16.0f)\n        zoomAnimator.duration = (duration * ANIMATION_DELAY_FACTOR).toLong()\n        zoomAnimator.interpolator = interpolator\n        zoomAnimator.addUpdateListener { animation: ValueAnimator -&gt;\n            maplibreMap.moveCamera(\n                CameraUpdateFactory.zoomTo((animation.animatedValue as Float).toDouble())\n            )\n        }\n        return zoomAnimator\n    }\n\n    //\n    // MapView lifecycle\n    //\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        mapView.onPause()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n        for (i in 0 until animators.size()) {\n            animators[animators.keyAt(i)]!!.cancel()\n        }\n        if (this::set.isInitialized) {\n            set.cancel()\n        }\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        if (::mapView.isInitialized) {\n            mapView.onDestroy()\n        }\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        if (::mapView.isInitialized) {\n            mapView.onLowMemory()\n        }\n    }\n\n    /** Helper class to evaluate LatLng objects with a ValueAnimator */\n    private class LatLngEvaluator : TypeEvaluator&lt;LatLng&gt; {\n        private val latLng = LatLng()\n        override fun evaluate(fraction: Float, startValue: LatLng, endValue: LatLng): LatLng {\n            latLng.latitude = startValue.latitude + (endValue.latitude - startValue.latitude) * fraction\n            latLng.longitude = startValue.longitude + (endValue.longitude - startValue.longitude) * fraction\n            return latLng\n        }\n    }\n\n    companion object {\n        private const val ANIMATION_DELAY_FACTOR = 1.5\n        private val START_LAT_LNG = LatLng(37.787947, -122.407432)\n    }\n\n    init {\n        val accelerateDecelerateAnimatorSet = AnimatorSet()\n        accelerateDecelerateAnimatorSet.playTogether(\n            createLatLngAnimator(START_LAT_LNG, LatLng(37.826715, -122.422795)),\n            obtainExampleInterpolator(FastOutSlowInInterpolator(), 2500)\n        )\n        animators.put(\n            R.id.menu_action_accelerate_decelerate_interpolator.toLong(),\n            accelerateDecelerateAnimatorSet\n        )\n        val bounceAnimatorSet = AnimatorSet()\n        bounceAnimatorSet.playTogether(\n            createLatLngAnimator(START_LAT_LNG, LatLng(37.787947, -122.407432)),\n            obtainExampleInterpolator(BounceInterpolator(), 3750)\n        )\n        animators.put(R.id.menu_action_bounce_interpolator.toLong(), bounceAnimatorSet)\n        animators.put(\n            R.id.menu_action_anticipate_overshoot_interpolator.toLong(),\n            obtainExampleInterpolator(AnticipateOvershootInterpolator(), 2500)\n        )\n        animators.put(\n            R.id.menu_action_path_interpolator.toLong(),\n            obtainExampleInterpolator(\n                PathInterpolatorCompat.create(.22f, .68f, 0f, 1.71f),\n                2500\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"camera/cameraposition/","title":"CameraPosition Capabilities","text":"<p>Note</p> <p>You can find the full source code of this example in <code>CameraPositionActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example showcases how to listen to camera change events.</p> <p>The camera animation is kicked off with this code: </p> <pre><code>val cameraPosition = CameraPosition.Builder().target(LatLng(latitude, longitude)).zoom(zoom).bearing(bearing).tilt(tilt).build()\n\nmaplibreMap?.animateCamera(\n    CameraUpdateFactory.newCameraPosition(cameraPosition),\n    5000,\n    object : CancelableCallback {\n        override fun onCancel() {\n            Timber.v(\"OnCancel called\")\n        }\n\n        override fun onFinish() {\n            Timber.v(\"OnFinish called\")\n        }\n    }\n)\n</code></pre> <p>Notice how the color of the button in the bottom right changes color. Depending on the state of the camera.</p> <p>We can listen for changes to the state of the camera by registering a <code>OnCameraMoveListener</code>, <code>OnCameraIdleListener</code>, <code>OnCameraMoveCanceledListener</code> or <code>OnCameraMoveStartedListener</code> with the <code>MapLibreMap</code>. For example, the <code>OnCameraMoveListener</code> is defined with:</p> <pre><code>private val moveListener = OnCameraMoveListener {\n    Timber.e(\"OnCameraMove\")\n    fab.setColorFilter(\n        ContextCompat.getColor(this@CameraPositionActivity, android.R.color.holo_orange_dark)\n    )\n}\n</code></pre> <p>And registered with:</p> <pre><code>maplibreMap.addOnCameraMoveListener(moveListener)\n</code></pre> <p>Refer to the full example to learn the methods to register the other types of camera change events.</p>"},{"location":"camera/gesture-detector/","title":"Gesture Detector","text":"<p>The gesture detector of MapLibre Android is encapsulated in the <code>maplibre-gestures-android</code> package.</p>"},{"location":"camera/gesture-detector/#gesture-listeners","title":"Gesture Listeners","text":"<p>You can add listeners for move, rotate, scale and shove gestures. For example, adding a move gesture listener with <code>MapLibreMap.addOnRotateListener</code>:</p> <pre><code>maplibreMap.addOnMoveListener(\n    object : OnMoveListener {\n        override fun onMoveBegin(detector: MoveGestureDetector) {\n            gestureAlertsAdapter!!.addAlert(\n                GestureAlert(GestureAlert.TYPE_START, \"MOVE START\")\n            )\n        }\n\n        override fun onMove(detector: MoveGestureDetector) {\n            gestureAlertsAdapter!!.addAlert(\n                GestureAlert(GestureAlert.TYPE_PROGRESS, \"MOVE PROGRESS\")\n            )\n        }\n\n        override fun onMoveEnd(detector: MoveGestureDetector) {\n            gestureAlertsAdapter!!.addAlert(\n                GestureAlert(GestureAlert.TYPE_END, \"MOVE END\")\n            )\n            recalculateFocalPoint()\n        }\n    }\n)\n</code></pre> <p>Refer to the full example below for examples of listeners for the other gesture types.</p>"},{"location":"camera/gesture-detector/#settings","title":"Settings","text":"<p>You can access an <code>UISettings</code> object via <code>MapLibreMap.uiSettings</code>. Available settings include:</p> <ul> <li>Toggle Quick Zoom. You can double tap on the map to use quick zoom. You can toggle this behavior on and off (<code>UiSettings.isQuickZoomGesturesEnabled</code>).</li> <li>Toggle Velocity Animations. By default flicking causes the map to continue panning (while decelerating). You can turn this off with <code>UiSettings.isScaleVelocityAnimationEnabled</code>.</li> <li>Toggle Rotate Enabled. Use <code>uiSettings.isRotateGesturesEnabled</code>.</li> <li>Toggle Zoom Enabled. Use <code>uiSettings.isZoomGesturesEnabled</code>.</li> </ul>"},{"location":"camera/gesture-detector/#full-example-activity","title":"Full Example Activity","text":"GestureDetectorActivity.kt<pre><code>package org.maplibre.android.testapp.activity.camera\n\nimport android.annotation.SuppressLint\nimport android.os.Bundle\nimport android.os.Handler\nimport android.os.Looper\nimport android.view.LayoutInflater\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.RelativeLayout\nimport android.widget.TextView\nimport androidx.annotation.ColorInt\nimport androidx.annotation.IntDef\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.content.ContextCompat\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\nimport org.maplibre.android.gestures.AndroidGesturesManager\nimport org.maplibre.android.gestures.MoveGestureDetector\nimport org.maplibre.android.gestures.RotateGestureDetector\nimport org.maplibre.android.gestures.ShoveGestureDetector\nimport org.maplibre.android.gestures.StandardScaleGestureDetector\nimport org.maplibre.android.annotations.Marker\nimport org.maplibre.android.annotations.MarkerOptions\nimport org.maplibre.android.camera.CameraUpdateFactory\nimport org.maplibre.android.geometry.LatLng\nimport org.maplibre.android.maps.MapLibreMap\nimport org.maplibre.android.maps.MapLibreMap.CancelableCallback\nimport org.maplibre.android.maps.MapLibreMap.OnMoveListener\nimport org.maplibre.android.maps.MapLibreMap.OnRotateListener\nimport org.maplibre.android.maps.MapLibreMap.OnScaleListener\nimport org.maplibre.android.maps.MapLibreMap.OnShoveListener\nimport org.maplibre.android.maps.MapView\nimport org.maplibre.android.testapp.R\nimport org.maplibre.android.testapp.styles.TestStyles\nimport org.maplibre.android.testapp.utils.FontCache\nimport org.maplibre.android.testapp.utils.ResourceUtils\n\n/** Test activity showcasing APIs around gestures implementation. */\nclass GestureDetectorActivity : AppCompatActivity() {\n    private lateinit var mapView: MapView\n    private lateinit var maplibreMap: MapLibreMap\n    private lateinit var recyclerView: RecyclerView\n    private var gestureAlertsAdapter: GestureAlertsAdapter? = null\n    private var gesturesManager: AndroidGesturesManager? = null\n    private var marker: Marker? = null\n    private var focalPointLatLng: LatLng? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_gesture_detector)\n        mapView = findViewById(R.id.mapView)\n        mapView.onCreate(savedInstanceState)\n        mapView.getMapAsync { map: MapLibreMap -&gt;\n            maplibreMap = map\n            maplibreMap.setStyle(TestStyles.getPredefinedStyleWithFallback(\"Streets\"))\n            initializeMap()\n        }\n        recyclerView = findViewById(R.id.alerts_recycler)\n        recyclerView.setLayoutManager(LinearLayoutManager(this))\n        gestureAlertsAdapter = GestureAlertsAdapter()\n        recyclerView.setAdapter(gestureAlertsAdapter)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        mapView.onResume()\n    }\n\n    override fun onPause() {\n        super.onPause()\n        gestureAlertsAdapter!!.cancelUpdates()\n        mapView.onPause()\n    }\n\n    override fun onStart() {\n        super.onStart()\n        mapView.onStart()\n    }\n\n    override fun onStop() {\n        super.onStop()\n        mapView.onStop()\n    }\n\n    override fun onLowMemory() {\n        super.onLowMemory()\n        mapView.onLowMemory()\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        mapView.onDestroy()\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mapView.onSaveInstanceState(outState)\n    }\n\n    private fun initializeMap() {\n        gesturesManager = maplibreMap.gesturesManager\n        val layoutParams = recyclerView.layoutParams as RelativeLayout.LayoutParams\n        layoutParams.height = (mapView.height / 1.75).toInt()\n        layoutParams.width = mapView.width / 3\n        recyclerView.layoutParams = layoutParams\n        attachListeners()\n        fixedFocalPointEnabled(maplibreMap.uiSettings.focalPoint != null)\n    }\n\n    fun attachListeners() {\n        // # --8&lt;-- [start:addOnMoveListener]\n        maplibreMap.addOnMoveListener(\n            object : OnMoveListener {\n                override fun onMoveBegin(detector: MoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"MOVE START\")\n                    )\n                }\n\n                override fun onMove(detector: MoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"MOVE PROGRESS\")\n                    )\n                }\n\n                override fun onMoveEnd(detector: MoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"MOVE END\")\n                    )\n                    recalculateFocalPoint()\n                }\n            }\n        )\n        // # --8&lt;-- [end:addOnMoveListener]\n        maplibreMap.addOnRotateListener(\n            object : OnRotateListener {\n                override fun onRotateBegin(detector: RotateGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"ROTATE START\")\n                    )\n                }\n\n                override fun onRotate(detector: RotateGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"ROTATE PROGRESS\")\n                    )\n                    recalculateFocalPoint()\n                }\n\n                override fun onRotateEnd(detector: RotateGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"ROTATE END\")\n                    )\n                }\n            }\n        )\n        maplibreMap.addOnScaleListener(\n            object : OnScaleListener {\n                override fun onScaleBegin(detector: StandardScaleGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"SCALE START\")\n                    )\n                    if (focalPointLatLng != null) {\n                        gestureAlertsAdapter!!.addAlert(\n                            GestureAlert(\n                                GestureAlert.TYPE_OTHER,\n                                \"INCREASING MOVE THRESHOLD\"\n                            )\n                        )\n                        gesturesManager!!.moveGestureDetector.moveThreshold =\n                            ResourceUtils.convertDpToPx(this@GestureDetectorActivity, 175f)\n                        gestureAlertsAdapter!!.addAlert(\n                            GestureAlert(\n                                GestureAlert.TYPE_OTHER,\n                                \"MANUALLY INTERRUPTING MOVE\"\n                            )\n                        )\n                        gesturesManager!!.moveGestureDetector.interrupt()\n                    }\n                    recalculateFocalPoint()\n                }\n\n                override fun onScale(detector: StandardScaleGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"SCALE PROGRESS\")\n                    )\n                }\n\n                override fun onScaleEnd(detector: StandardScaleGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"SCALE END\")\n                    )\n                    if (focalPointLatLng != null) {\n                        gestureAlertsAdapter!!.addAlert(\n                            GestureAlert(\n                                GestureAlert.TYPE_OTHER,\n                                \"REVERTING MOVE THRESHOLD\"\n                            )\n                        )\n                        gesturesManager!!.moveGestureDetector.moveThreshold = 0f\n                    }\n                }\n            }\n        )\n        maplibreMap.addOnShoveListener(\n            object : OnShoveListener {\n                override fun onShoveBegin(detector: ShoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_START, \"SHOVE START\")\n                    )\n                }\n\n                override fun onShove(detector: ShoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_PROGRESS, \"SHOVE PROGRESS\")\n                    )\n                }\n\n                override fun onShoveEnd(detector: ShoveGestureDetector) {\n                    gestureAlertsAdapter!!.addAlert(\n                        GestureAlert(GestureAlert.TYPE_END, \"SHOVE END\")\n                    )\n                }\n            }\n        )\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        menuInflater.inflate(R.menu.menu_gestures, menu)\n        return true\n    }\n\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        val uiSettings = maplibreMap.uiSettings\n        when (item.itemId) {\n            R.id.menu_gesture_focus_point -&gt; {\n                fixedFocalPointEnabled(focalPointLatLng == null)\n                return true\n            }\n            R.id.menu_gesture_animation -&gt; {\n                uiSettings.isScaleVelocityAnimationEnabled =\n                    !uiSettings.isScaleVelocityAnimationEnabled\n                uiSettings.isRotateVelocityAnimationEnabled =\n                    !uiSettings.isRotateVelocityAnimationEnabled\n                uiSettings.isFlingVelocityAnimationEnabled =\n                    !uiSettings.isFlingVelocityAnimationEnabled\n                return true\n            }\n            R.id.menu_gesture_rotate -&gt; {\n                uiSettings.isRotateGesturesEnabled = !uiSettings.isRotateGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_tilt -&gt; {\n                uiSettings.isTiltGesturesEnabled = !uiSettings.isTiltGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_zoom -&gt; {\n                uiSettings.isZoomGesturesEnabled = !uiSettings.isZoomGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_scroll -&gt; {\n                uiSettings.isScrollGesturesEnabled = !uiSettings.isScrollGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_double_tap -&gt; {\n                uiSettings.isDoubleTapGesturesEnabled = !uiSettings.isDoubleTapGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_quick_zoom -&gt; {\n                uiSettings.isQuickZoomGesturesEnabled = !uiSettings.isQuickZoomGesturesEnabled\n                return true\n            }\n            R.id.menu_gesture_scroll_horizontal -&gt; {\n                uiSettings.isHorizontalScrollGesturesEnabled =\n                    !uiSettings.isHorizontalScrollGesturesEnabled\n                return true\n            }\n        }\n        return super.onOptionsItemSelected(item)\n    }\n\n    private fun fixedFocalPointEnabled(enabled: Boolean) {\n        if (enabled) {\n            focalPointLatLng = LatLng(51.50325, -0.12968)\n            marker = maplibreMap.addMarker(MarkerOptions().position(focalPointLatLng))\n            maplibreMap.easeCamera(\n                CameraUpdateFactory.newLatLngZoom(focalPointLatLng!!, 16.0),\n                object : CancelableCallback {\n                    override fun onCancel() {\n                        recalculateFocalPoint()\n                    }\n\n                    override fun onFinish() {\n                        recalculateFocalPoint()\n                    }\n                }\n            )\n        } else {\n            if (marker != null) {\n                maplibreMap.removeMarker(marker!!)\n                marker = null\n            }\n            focalPointLatLng = null\n            maplibreMap.uiSettings.focalPoint = null\n        }\n    }\n\n    private fun recalculateFocalPoint() {\n        if (focalPointLatLng != null) {\n            maplibreMap.uiSettings.focalPoint =\n                maplibreMap.projection.toScreenLocation(focalPointLatLng!!)\n        }\n    }\n\n    private class GestureAlertsAdapter : RecyclerView.Adapter&lt;GestureAlertsAdapter.ViewHolder&gt;() {\n        private var isUpdating = false\n        private val updateHandler = Handler(Looper.getMainLooper())\n        private val alerts: MutableList&lt;GestureAlert&gt; = ArrayList()\n\n        class ViewHolder internal constructor(view: View) : RecyclerView.ViewHolder(view) {\n            var alertMessageTv: TextView\n\n            init {\n                val typeface = FontCache.get(\"Roboto-Regular.ttf\", view.context)\n                alertMessageTv = view.findViewById(R.id.alert_message)\n                alertMessageTv.typeface = typeface\n            }\n        }\n\n        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {\n            val view =\n                LayoutInflater.from(parent.context)\n                    .inflate(R.layout.item_gesture_alert, parent, false)\n            return ViewHolder(view)\n        }\n\n        override fun onBindViewHolder(holder: ViewHolder, position: Int) {\n            val alert = alerts[position]\n            holder.alertMessageTv.text = alert.message\n            holder.alertMessageTv.setTextColor(\n                ContextCompat.getColor(holder.alertMessageTv.context, alert.color)\n            )\n        }\n\n        override fun getItemCount(): Int {\n            return alerts.size\n        }\n\n        fun addAlert(alert: GestureAlert) {\n            for (gestureAlert in alerts) {\n                if (gestureAlert.alertType != GestureAlert.TYPE_PROGRESS) {\n                    break\n                }\n                if (alert.alertType == GestureAlert.TYPE_PROGRESS &amp;&amp; gestureAlert == alert) {\n                    return\n                }\n            }\n            if (itemCount &gt;= MAX_NUMBER_OF_ALERTS) {\n                alerts.removeAt(itemCount - 1)\n            }\n            alerts.add(0, alert)\n            if (!isUpdating) {\n                isUpdating = true\n                updateHandler.postDelayed(updateRunnable, 250)\n            }\n        }\n\n        @SuppressLint(\"NotifyDataSetChanged\")\n        private val updateRunnable = Runnable {\n            notifyDataSetChanged()\n            isUpdating = false\n        }\n\n        fun cancelUpdates() {\n            updateHandler.removeCallbacksAndMessages(null)\n        }\n    }\n\n    private class GestureAlert(\n        @field:Type @param:Type\n        val alertType: Int,\n        val message: String?\n    ) {\n        @Retention(AnnotationRetention.SOURCE)\n        @IntDef(TYPE_NONE, TYPE_START, TYPE_PROGRESS, TYPE_END, TYPE_OTHER)\n        annotation class Type\n\n        @ColorInt var color = 0\n        override fun equals(other: Any?): Boolean {\n            if (this === other) {\n                return true\n            }\n            if (other == null || javaClass != other.javaClass) {\n                return false\n            }\n            val that = other as GestureAlert\n            if (alertType != that.alertType) {\n                return false\n            }\n            return if (message != null) message == that.message else that.message == null\n        }\n\n        override fun hashCode(): Int {\n            var result = alertType\n            result = 31 * result + (message?.hashCode() ?: 0)\n            return result\n        }\n\n        companion object {\n            const val TYPE_NONE = 0\n            const val TYPE_START = 1\n            const val TYPE_END = 2\n            const val TYPE_PROGRESS = 3\n            const val TYPE_OTHER = 4\n        }\n\n        init {\n            when (alertType) {\n                TYPE_NONE -&gt; color = android.R.color.black\n                TYPE_END -&gt; color = android.R.color.holo_red_dark\n                TYPE_OTHER -&gt; color = android.R.color.holo_purple\n                TYPE_PROGRESS -&gt; color = android.R.color.holo_orange_dark\n                TYPE_START -&gt; color = android.R.color.holo_green_dark\n            }\n        }\n    }\n\n    companion object {\n        private const val MAX_NUMBER_OF_ALERTS = 30\n    }\n}\n</code></pre>"},{"location":"camera/lat-lng-bounds/","title":"LatLngBounds API","text":"<p>Note</p> <p>You can find the full source code of this example in <code>LatLngBoundsActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example demonstrates setting the camera to some bounds defined by some features. It sets these bounds when the map is initialized and when the bottom sheet is opened or closed.</p> <p>Here you can see how the feature collection is loaded and how <code>MapLibreMap.getCameraForLatLngBounds</code> is used to set the bounds during map initialization:</p> <pre><code>val featureCollection: FeatureCollection =\n    fromJson(GeoParseUtil.loadStringFromAssets(this, \"points-sf.geojson\"))\nbounds = createBounds(featureCollection)\n\nmap.getCameraForLatLngBounds(bounds, createPadding(peekHeight))?.let {\n    map.cameraPosition = it\n}\n</code></pre> <p>The <code>createBounds</code> function uses the <code>LatLngBounds</code> API to include all points within the bounds:</p> <pre><code>private fun createBounds(featureCollection: FeatureCollection): LatLngBounds {\n    val boundsBuilder = LatLngBounds.Builder()\n    featureCollection.features()?.let {\n        for (feature in it) {\n            val point = feature.geometry() as Point\n            boundsBuilder.include(LatLng(point.latitude(), point.longitude()))\n        }\n    }\n    return boundsBuilder.build()\n}\n</code></pre>"},{"location":"camera/min-max-zoom/","title":"Min/Max Zoom","text":"<p>Note</p> <p>You can find the full source code of this example in <code>MaxMinZoomActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows how to configure a maximum and a minimum zoom level.</p> <pre><code>maplibreMap.setMinZoomPreference(3.0)\nmaplibreMap.setMaxZoomPreference(5.0)\n</code></pre>"},{"location":"camera/min-max-zoom/#bonus-add-click-listener","title":"Bonus: Add Click Listener","text":"<p>As a bonus, this example also shows how you can define a click listener to the map.</p> <pre><code>maplibreMap.addOnMapClickListener {\n    if (this::maplibreMap.isInitialized) {\n        maplibreMap.setStyle(Style.Builder().fromUri(TestStyles.AMERICANA))\n    }\n    true\n}\n</code></pre> <p>You can remove a click listener again with <code>MapLibreMap.removeOnMapClickListener</code>. To use this API you need to assign the click listener to a variable, since you need to pass the listener to that method.</p>"},{"location":"camera/move-map-pixels/","title":"Scroll by Method","text":"<p>Note</p> <p>You can find the full source code of this example in <code>ScrollByActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows how you can move the map by x/y pixels.</p> <pre><code>maplibreMap.scrollBy(\n    (seekBarX.progress * MULTIPLIER_PER_PIXEL).toFloat(),\n    (seekBarY.progress * MULTIPLIER_PER_PIXEL).toFloat()\n)\n</code></pre>"},{"location":"camera/zoom-methods/","title":"Zoom Methods","text":"<p>Note</p> <p>You can find the full source code of this example in <code>ManualZoomActivity.kt</code> of the MapLibreAndroidTestApp.</p> <p>This example shows different methods of zooming in.</p> <p>Each method uses <code>MapLibreMap.animateCamera</code>, but with a different <code>CameraUpdateFactory</code>.</p>"},{"location":"camera/zoom-methods/#zooming-in","title":"Zooming In","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomIn())\n</code></pre>"},{"location":"camera/zoom-methods/#zooming-out","title":"Zooming Out","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomOut())\n</code></pre>"},{"location":"camera/zoom-methods/#zoom-by-some-amount-of-zoom-levels","title":"Zoom By Some Amount of Zoom Levels","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomBy(2.0))\n</code></pre>"},{"location":"camera/zoom-methods/#zoom-to-a-zoom-level","title":"Zoom to a Zoom Level","text":"<pre><code>maplibreMap.animateCamera(CameraUpdateFactory.zoomTo(2.0))\n</code></pre>"},{"location":"camera/zoom-methods/#zoom-to-a-point","title":"Zoom to a Point","text":"<pre><code>val view = window.decorView\nmaplibreMap.animateCamera(\n    CameraUpdateFactory.zoomBy(\n        1.0,\n        Point(view.measuredWidth / 4, view.measuredHeight / 4)\n    )\n)\n</code></pre>"}]}